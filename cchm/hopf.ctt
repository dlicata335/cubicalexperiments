module hopf where

import susp
import s1
import join
import pointedtypes


S2 : U = Susp S1

data nat = zero | suc (n : nat)

hopf : S2 -> U = split
  north -> S1
  south -> S1
  merid a @ x -> rotpath a @ x

totalHopfToJoin : (a : S2) -> hopf a -> Join S1 S1 = split
  north -> \ (a : S1) -> joinl (comp (<_> S1) a [])
  south -> \ (a : S1) -> joinr (comp (<_> S1) a [])
  merid a @ x ->
   \(p : rotpath a @ x) ->
     join{Join S1 S1}
       (comp (<y> rotpath a @ -y /\ x) p [])
       (comp (<y> rotpath a @ y \/ x) p [])
       @ x

one : nat = suc zero
two : nat = suc one
three : nat = suc two

S3 : U = Susp S2
ptS3 : PointedType = (S3, north)
ptS2 : PointedType = (S2, north)
ptS1 : PointedType = (S1, base)


Omega (Z : PointedType) : PointedType = (Path Z.1 (Z.2) (Z.2), <_> Z.2)

-- Iterated loop space
itOmega : nat -> PointedType -> PointedType = split
  zero  -> \ (A:PointedType) -> A
  suc n -> \(A:PointedType) -> itOmega n (Omega A)

fibOmega (B : PointedType) (P : B.1 -> U) (f : P (B.2)) (p : (Omega B).1) : U =
 PathP (<i> P (p @ i)) f f

itFibOmega : (n : nat) (B : PointedType) (P : B.1 -> U) (f : P (B.2)) -> (itOmega n B).1 -> U
 = split
  zero  -> \ (B : PointedType) (P : B.1 -> U) (f : P (B.2)) -> P
  suc n -> \ (B : PointedType) (P : B.1 -> U) (f : P (B.2)) -> itFibOmega n (Omega B) (fibOmega B P f) (refl (P (B.2)) f)

hopfOne : (itOmega one ptS2).1 -> U = itFibOmega one ptS2 hopf base

hopfTwo : (itOmega two ptS2).1 -> U = itFibOmega two ptS2 hopf base

hopfThree : (itOmega three ptS2).1 -> U = itFibOmega three ptS2 hopf base


