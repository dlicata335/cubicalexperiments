module hopf where

import prelude
import susp
import s1
import join
import pointedtypes
import helix


S2 : U = Susp S1

hopf : S2 -> U = split
  north -> S1
  south -> S1
  merid a @ x -> rotpath a @ x

hopfToJoin : (a : S2) -> hopf a -> Join S1 S1 = split
  north -> \ (a : S1) -> joinl (comp (<_> S1) a [])
  south -> \ (a : S1) -> joinr (comp (<_> S1) a [])
  merid a @ x ->
   \(p : rotpath a @ x) ->
     join{Join S1 S1}
       (comp (<y> rotpath a @ -y /\ x) p [])
       (comp (<y> rotpath a @ y \/ x) p [])
       @ x

totalHopfToJoin (e : (a : S2) * hopf a) : Join S1 S1 =
  hopfToJoin e.1 e.2

S3 : U = Susp S2
ptS3 : PointedType = (S3, north)
ptS2 : PointedType = (S2, north)
ptS1 : PointedType = (S1, base)


hopfOne : (itOmega one ptS2).1 -> U = itFibOmega one ptS2 hopf base

hopfTwo : (itOmega two ptS2).1 -> U = itFibOmega two ptS2 hopf base

hopfThree : (itOmega three ptS2).1 -> U = itFibOmega three ptS2 hopf base

ptJoin (pA:PointedType) (B:U) : PointedType = (Join pA.1 B, joinl (pt pA))


lemPropFibS1 (P : S1 -> U) (pP : (x:S1) -> HProp (P x)) (bP: P base) : (x:S1) -> P x = split
 base -> bP
 loop @ i -> (lemPropF S1 P pP base base loopS1 bP bP) @ i


fibContrHopfThree (p : (itOmega three ptS2).1) : hopfThree p =
  truncFibOmega
    (itOmega two ptS2)
    hopfTwo
    (<_> <_> base)
    zero
    (truncFibOmega
      (Omega ptS2)
      hopfOne
      (<_> base)
      one
      (truncFibOmega ptS2 hopf base two isOneTypeS1 (<_> north))
      (<_> pt (Omega ptS2)))
    p
  where
    isOneTypeS1 : OneType S1 =
      lemPropFibS1
        (\(x:S1) -> (y:S1) -> HSet (Path S1 x y))
        (\(x:S1) ->
          Pi_level_prop
            S1
            (\(y:S1) -> HSet (Path S1 x y))
            (\(y:S1) -> setIsProp (Path S1 x y)))
        (lemPropFibS1
          (\ (y:S1) -> HSet (Path S1 base y))
          (\ (y:S1) -> setIsProp (Path S1 base y))
          setLoop)


-- The map h from 9.3
hopfLoop (p : (itOmega three ptS2).1) : (itOmega three (ptJoin ptS1 S1)).1 =
  trans bad_type good_type path_fix bad_thing
  where
  bad_type : U =
    Path
      (Path
        (Path (Join S1 S1) (joinl (comp (<_> S1) base [])) (joinl (comp (<_> S1) base [])))
        (<_> joinl (comp (<_> S1) base []))
        (<_> joinl (comp (<_> S1) base [])))
      (<_ _> joinl (comp (<_> S1) base []))
      (<_ _> joinl (comp (<_> S1) base []))

  good_type : U = Path (Path (Path (Join S1 S1) (joinl base) (joinl base)) (<_> joinl base) (<_> joinl base)) (<!0 !0> joinl base) (<!0 !0> joinl base)

  uncomp : Path S1 (comp (<_> S1) base []) base =
    <x> fill (<_> S1) base [] @ -x

  path_fix : Path U bad_type good_type =
    <x> Path
          (Path
            (Path (Join S1 S1) (joinl (uncomp @ x)) (joinl (uncomp @ x)))
            (<_> joinl (uncomp @ x))
            (<_> joinl (uncomp @ x)))
          (<_ _> joinl (uncomp @ x))
          (<_ _> joinl (uncomp @ x))


  bad_thing : bad_type
    =
      itMapOmegaRefl
        three
        ((a : S2) * hopf a, (north, base))
        (Join S1 S1)
        totalHopfToJoin
        (itTotalFibOmega three ptS2 hopf base (p, fibContrHopfThree p))


