module hopf where

import prelude
import susp
import s1
import join
import pointedtypes


S2 : U = Susp S1

hopf : S2 -> U = split
  north -> S1
  south -> S1
  merid a @ x -> rotpath a @ x

totalHopfToJoin : (a : S2) -> hopf a -> Join S1 S1 = split
  north -> \ (a : S1) -> joinl (comp (<_> S1) a [])
  south -> \ (a : S1) -> joinr (comp (<_> S1) a [])
  merid a @ x ->
   \(p : rotpath a @ x) ->
     join{Join S1 S1}
       (comp (<y> rotpath a @ -y /\ x) p [])
       (comp (<y> rotpath a @ y \/ x) p [])
       @ x


S3 : U = Susp S2
ptS3 : PointedType = (S3, north)
ptS2 : PointedType = (S2, north)
ptS1 : PointedType = (S1, base)


hopfOne : (itOmega one ptS2).1 -> U = itFibOmega one ptS2 hopf base

hopfTwo : (itOmega two ptS2).1 -> U = itFibOmega two ptS2 hopf base

hopfThree : (itOmega three ptS2).1 -> U = itFibOmega three ptS2 hopf base

ptJoin (pA:PointedType) (B:U) : PointedType = (Join pA.1 B, joinl (pt pA))


lemPropFibS1 (P : S1 -> U) (pP : (x:S1) -> HProp (P x)) (bP: P base) : (x:S1) -> P x = split
 base -> bP
 loop @ i -> (lemPropF S1 P pP base base loopS1 bP bP) @ i

-- is there a direct way to show this? In the cubicaltt repo (and Brunerie's thesis), the proof of this uses the fact that
-- pi1S1 = Z
setLoop : HSet (Path S1 base base) =
  ?

fibContrHopfThree (p : (itOmega three ptS2).1) : hopfThree p =
  truncFibOmega
    (itOmega two ptS2)
    hopfTwo
    (<_> <_> base)
    zero
    (truncFibOmega
      (Omega ptS2)
      hopfOne
      (<_> base)
      one
      (truncFibOmega ptS2 hopf base two isOneTypeS1 (<_> north))
      (<_> pt (Omega ptS2)))
    p
  where
    isOneTypeS1 : OneType S1 =
      lemPropFibS1
        (\(x:S1) -> (y:S1) -> HSet (Path S1 x y))
        (\(x:S1) ->
          Pi_level_prop
            S1
            (\(y:S1) -> HSet (Path S1 x y))
            (\(y:S1) -> setIsProp (Path S1 x y)))
        (lemPropFibS1
          (\ (y:S1) -> HSet (Path S1 base y))
          (\ (y:S1) -> setIsProp (Path S1 base y))
          setLoop)



