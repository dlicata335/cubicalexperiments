module pi4s3 where


import int
import join
-- import hopf
import pointedtypes
-- import circle12
import susp
import joinassoc
-- import helix
-- import exchange





--TEST --
-- p : Path (Join Bool S2) (joinl true) (joinl false) =
--   <i> suspJoin S2 (merid {S3} (joinl true) @ i)


-- p2 : Path (Join Bool S2) (joinl true) (joinl false) =
--   <i> (compPath (Join Bool S2) (joinl true) (joinr (joinl true)) (joinl false)
--                        (<i> join {Join Bool S2} true (joinl true) @ i)
--                        (<i> (join {Join Bool S2} false (joinl true)) @-i)
--                     @ i)

-- p3  : Path (Join Bool S2) (joinl true) (joinl false) =
--     <i> (comp (<j>Join Bool S2) (join {Join Bool S2} true (joinl true) @ i)
--            [ (i = 1) -> (<k> (join {Join Bool S2} false (joinl true)) @-k)
--            , (i=0) -> <j> (joinl true) ])

-- t1 : Path (Join Bool S2) (joinl true) (joinr (joinl true))  =
--      <i> join {Join Bool S2} true (joinl true) @ i


----END TEST---

case1 (A : U) : Bool -> Susp A = split
  true ->  (joinl true)
  false -> (joinl false)


suspJoinInv (A : U) : Join Bool A -> Susp A =  \(x : Join Bool A) -> x

ptJoin (pA : PointedType) (B:U) : PointedType = (Join pA.1 B, joinl (pt pA))

ptBool : PointedType = (Bool,true)

bjbToS1 (x:Join Bool Bool) : S1 = (suspJoinInv Bool x)

bjbToS1Inv (x : S1) : Join Bool Bool = suspJoin Bool (x)

-- The map e^-1 from 7.3
-- s3ToS1JoinS1Inv (x : Join S1 S1) : S3 =
--   suspJoinInv S2
--     (mapJoin Bool (Join Bool S1) Bool S2 (\(b:Bool) -> b) (suspJoinInv S1)
--       (jassoc_lr Bool Bool S1
--         (mapJoin S1 S1 (Join Bool Bool) S1 bjbToS1Inv (\(z:S1) -> z) x)))


-- s3To22S1 (x: S3) : Join (Join Bool Bool) S1 = split
--   (joinl true) -> ?
--   (joinl false) -> ?
--   merid

-- The map e from 7.3
s3ToS1JoinS1 (x:S3) : Join S1 S1 = (jassoc_rl Bool Bool S1 x)




-- A modified version of the main map alpha from 8, which is equal to the
-- other one (to be checked) but pointed by reflexivity
alpha : Join S1 S1 -> S2 = split
  joinl x   -> (joinl true)
  joinr y   -> (joinl true)
  join x y @ i -> (compPath S2 (joinl true) (joinl false) (joinl true) (merid S1 x) (<j>merid S1 y@-j))@i

ptAlpha : PointedMap (ptJoin ptS1 S1) ptS2 = (alpha, refl S2 (joinl true))

-- Letâ€™s define the twelve maps first

-- f0 : Z -> OmegaS1 = loopIt

ptSusp (A : U) : PointedType = (Susp A, (joinl true))

sigma (A : PointedType) : PointedMap A (Omega (ptSusp A.1))=
 (s,s0)
  where s (x:A.1) : Path (Susp A.1) (joinl true) (joinl true)
         = compPath (Susp A.1) (joinl true) (joinl false) (joinl true)
                  (merid A.1 x)
                  (<i>(merid A.1 (pt A))@-i)

        s0 : Path (Omega (ptSusp A.1)).1
                  (s (pt A))
                  (refl (Susp A.1) (joinl true))
         = compInvRight (Susp A.1) (joinl true) (joinl false) (merid  A.1 (pt A))

f1 : OmegaS1 -> (itOmega two ptS2).1 = (OmegaF ptS1 (Omega ptS2) (sigma ptS1)).1

f2 : (itOmega two ptS2).1 -> (itOmega three ptS3).1 =
 (itMapOmega two ptS2 (Omega ptS3) (sigma ptS2)).1

f3 : (itOmega three ptS3).1 -> (itOmega three (ptJoin ptS1 S1)).1
 = itMapOmegaRefl three ptS3 (Join S1 S1) s3ToS1JoinS1


f4 : (itOmega three (ptJoin ptS1 S1)).1 -> (itOmega three ptS2).1
 = itMapOmegaRefl three (ptJoin ptS1 S1) S2 ptAlpha.1

f34 : (itOmega three ptS3).1 -> (itOmega three ptS2).1 =
  itMapOmegaRefl three ptS3 S2 (\(x : S3) -> ptAlpha.1 (s3ToS1JoinS1 x))

-- f5 : (itOmega three ptS2).1 -> (itOmega three (ptJoin ptS1 S1)).1
--  = hopfLoop

-- oneZ : Z = sucZ zeroZ

-- WORKS
test0To1 : (itOmega two ptS2).1 = f1 loop -- (f0 oneZ)

-- WORKS
test0To2 : (itOmega three ptS3).1 = f2 test0To1

-- WORKS
test0To3 : (itOmega three (ptJoin ptS1 S1)).1 = f3 test0To2

-- WORKS
test0To4 : (itOmega three ptS2).1 = f4 test0To3

test34 : (itOmega three ptS2).1 = f34 test0To2

-- -- NOT SURE (takes a long time)
-- test0To5 : (itOmega three (ptJoin ptS1 S1)).1 = f5 test0To4

-- -- -- Test f5 on a generator given by the exchange law
-- -- -- testf5 : (itOmega three (ptJoin ptS1 S1)).1 = f5 genPi3S2
