module s1 where

import prelude
import equiv
import pointedtypes
import susp


-- data OldCircle = base
--                | loop <i> [(i=0) -> base, (i=1) -> base]


-- oldToNewS1 : OldCircle -> S1 = split
--   base -> joinl true
--   loop @ i -> comp (<_> S1)
--        	      (merid Bool true @ i)
-- 	      (




-- OldCircleP : PointedType = (OldCircle, base)

-- -- helpful abbreviations
-- OmegaOldCircle : U = Path OldCircle base base

-- compOldCircle (p : OmegaOldCircle) (q : OmegaOldCircle) : OmegaOldCircle = <x> comp (<_> OldCircle) (p @ x) [(x=0) -> <_> base, (x=1) -> q]
-- loopOldCircle : OmegaOldCircle = <i> loop{OldCircle} @ i
-- loopOldCircle_2 : OmegaOldCircle= compOldCircle loopOldCircle loopOldCircle


-- invLoop : OmegaOldCircle = <i> loop {OldCircle} @ -i


-- -- "rotation by angle x"
-- -- adds loops

-- rotLoop : (a : OldCircle) -> Path OldCircle a a = split
--   base -> loopOldCircle
--   loop @ i -> constSquare OldCircle base loopOldCircle @ i





rotLoop : (a : S1) -> Path S1 a a = split
  joinl a -> loop
  joinr a -> ? -- loop
  join x y @ i -> ? --aux x y @ i
     -- where
     --   aux (x y : Bool) : Path OmegaS1 loop loop = 
     --     ?
         -- if (Path OmegaS1 loop loop) (and x y)
	 --   --then 
	 --   (constSquare S1 (joinl true) loop @ i)
	 --   -- else
	 --   ?
       	   
       	   


-- rot : OldCircle -> OldCircle -> OldCircle = split
--   base -> (\ (y : OldCircle) -> y)
--   loop @ i -> (\ (y : OldCircle) -> rotLoop y @ i)

-- rot_unit_r : (a : OldCircle) -> Path OldCircle (rot a base) a = split
--    base -> <_> base
--    loop@x -> <_> loop{OldCircle}@x

-- loopOldCircle_3 : Path OldCircle base base = compOldCircle loopOldCircle_2 loopOldCircle
-- -- test23 : PathP (<s> Path OldCircle (loopOldCircle_3 @ s) (loopOldCircle_3 @ s)) loopOldCircle_2 loopOldCircle_2 = <x> <y> rot (loopOldCircle_3 @ x) (loopOldCircle_2 @ y)
-- -- test23_diag : Path OldCircle base base = <x> test23 @ x @ x

-- -- at this point we have an hspace, so we could use the general proof that rot x and (\ x -> rot x y)
-- -- are equivalences.  however, it's simpler to inline the connectedness argument for this case

-- rotIsEquiv_loop : PathP (<x> IsEquiv OldCircle OldCircle (rot (loopOldCircle @ x))) (lemSinglContr OldCircle) (lemSinglContr OldCircle) =
--   lemPropF
--     OldCircle
--     (\(a : OldCircle) -> IsEquiv OldCircle OldCircle (rot a))
--     (\(a : OldCircle) -> propIsEquiv OldCircle OldCircle (rot a))
--     base
--     base
--     loopOldCircle
--     (lemSinglContr OldCircle)
--     (lemSinglContr OldCircle)


-- rotIsEquiv : (a : OldCircle) -> IsEquiv OldCircle OldCircle (rot a) = split
--    base -> lemSinglContr OldCircle
--    loop @ x -> rotIsEquiv_loop @ x

-- rotpath (x : OldCircle) : Path U OldCircle OldCircle = ua OldCircle OldCircle (rot x, rotIsEquiv x)

-- -- -- too slow if we allow this to reduce always
-- -- rotright_IsEquiv_base : Unit -> IsEquiv OldCircle OldCircle (\ (a : OldCircle) -> rot a base) = split
-- --   tt -> transport (<x> IsEquiv OldCircle OldCircle (\ (a : OldCircle) -> rot_unit_r a @ -x)) (idfun_IsEquiv OldCircle)

-- -- rotright_IsEquiv : (b : OldCircle) -> IsEquiv OldCircle OldCircle (\ (a : OldCircle) -> rot a b) = split
-- --   base -> rotright_IsEquiv_base STUCK
-- --   loop@x -> use_IsEquiv_level_het OldCircle OldCircle
-- --             (\ (a : OldCircle) -> rot a base) (\ (a : OldCircle) -> rot a base)
-- --             (<x> \ (a : OldCircle) -> rot a (loop{OldCircle} @ x))
-- --             (rotright_IsEquiv_base STUCK)
-- --             (rotright_IsEquiv_base STUCK) @ x

-- -- rotpath_right (b : OldCircle) : Path U OldCircle OldCircle =
-- --   ua OldCircle OldCircle (\ (x : OldCircle) -> rot x b) (rotright_IsEquiv b)

-- -- -- evidence that a rotated by something is b
-- -- Rot (a : OldCircle) (b : OldCircle) : U = (c : OldCircle) * PathP (rotpath c) a b

-- -- -- only uses the hspace axioms, so would work for the general hopf construction
-- -- Rot_level (a : OldCircle) (b : OldCircle) : Contractible (Rot a b) =
-- --  transport (<x> Contractible (((c : OldCircle) * equiv c STUCK @ -x))) (Singleton_level OldCircle (transport (<x> rotpath_right a @ -x) b))
-- --  where
-- --   equiv (c : OldCircle) : Unit -> Path U (PathP (rotpath c) a b) (Path OldCircle (transport (<x> rotpath_right a @ -x) b) c) = split
-- --    tt ->
-- --     compU (PathP (rotpath c) a b)
-- --           (Path OldCircle (transport (rotpath c) a) b)
-- --           (Path OldCircle (transport (<x> rotpath_right a @ -x) b) c)
-- --           (<x> hom_to_het_1_path OldCircle OldCircle (rotpath c) a b @ -x)
-- --           (compU (Path OldCircle (rot c a) b)
-- --                  (Path OldCircle c (transport (<x> rotpath_right a @ -x) b))
-- --                  (Path OldCircle (transport (<x> rotpath_right a @ -x) b) c)
-- --                  (move_transport_right_path OldCircle OldCircle (rotpath_right a) c b)
-- --                  (inv_path OldCircle c (transport (<x> rotpath_right a @ -x) b)))

-- -- findRot (a : OldCircle) (b : OldCircle) : Rot a b = (Rot_level a b).1
-- -- anyRot (a : OldCircle) (b : OldCircle) (r : Rot a b) : Path (Rot a b) (findRot a b) r = (Rot_level a b).2 r

-- -- rot is commutative, but we don't use this fact below

-- -- rot_comm_square : (a : OldCircle) -> PathP (<x> Path OldCircle (rot a (loop{OldCircle}@x)) (rotLoop a @ x))
-- --                                   (rot_unit_r a)
-- --                                   (rot_unit_r a) = split
-- --    base -> <x><y>loop{OldCircle}@x
-- --    loop@z -> <x> <y> (rotLoop (loop{OldCircle}@z) @ x)

-- -- rot_comm (a : OldCircle) : (b : OldCircle) -> Path OldCircle (rot a b) (rot b a) = split
-- --    base -> rot_unit_r a
-- --    loop @ x -> rot_comm_square a @ x
